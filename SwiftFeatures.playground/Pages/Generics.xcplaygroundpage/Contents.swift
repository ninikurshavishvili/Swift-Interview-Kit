//: [Previous](@previous)

import Foundation

//Generics

/*
 Generic-ების გამოყენებით შეგიძლია დაწერო კოდი რომელიც სხვადასხვა ტიპებს ემუშავება, და განუსაზღვრო სხვადასხვა requirements (მოთხოვნები) აპ ტიპებს რომლებსაც ემუშავები.
 
 Generic-ები საშუალებას გვაძლევს დავწეროთ ყველაზე მოქნილი და reusable ფუნქციები, რომელიც ემუშავება ყველა ტიპის ობიექტს. მისი გამოყენებით თავიდან ავირიდებთ დუბლიკატებს, გამეორებულ კოდის ფუნქციებს და პროექტის სტრუქტურაც მედაც სუფთა იქნება.
 Generic-ები Swift-ის ერთ-ერთი ყველაზე ძლიერი feture-ია და Swift-ის სტანდარტული librery generic კოდით არის აგებული. მაგალითად : Array, Dictionary ტიპები არის Generic კოლექციები. (ანუ შეგვიძლია შევქმნათ მასივი რომელიც შეიცავს Int მნიშვნელობებს ან string მნიშვნელობებს. ისვე როგორც Dictionary ნებისმიერი ტიპის key, value წყვილები.
 */

//პრობლემა რომელსაც უშუალოდ Generic-ები წყვეტენ

/** ფუნქცია გადაცვლის ჩვენს მიერ მიწოდებულ ორ მთელი რიცხვების მნიშვნელობებს*/
func swapTwoInts(_ a: inout Int, _ b: inout Int) {
    let temporaryA = a
    a = b
    b = temporaryA
}

// მაგალთად

var x = 5
var y = 10

swapTwoInts(&x, &y)

print(x) //"10\n"
print(y) //"5\n"

/* თუმცა თუ გინდა რომ String მნიშვნელობები გადაცვალო, ამისათვის დაგჭირდება მეტი ფუნქცია*/

func swapTwoStrings(_ a: inout String, _ b: inout String) {
    let temporaryA = a
    a = b
    b = temporaryA
}


func swapTwoDoubles(_ a: inout Double, _ b: inout Double) {
    let temporaryA = a
    a = b
    b = temporaryA
}

/* მთავარი რაც აქ უნდა დაიმახსოროთ არის: a და b მნიშვნელობები ორივე უნდა იყოს ერთი ტიპის (რადგანაც Swift Type Safe ენაა და არ გრთავს ნებას მაგალითად String და Double მნიშვნელლობები გადაცვალო ერთმანეთში, ეს გამოიწვევს Compile-time error-ს*/

/*შეამჩნევდით რომ სამივე ფუნქცია გავს ერთმანეთს მხოლოდ Type-ებია განსხვავებული, სწორედ აქ შემოდის Generic კოდის ძალა. შემოგთავაზებთ ერთ ფუნქციას რომელიც მუშაობს ყველა ტიპისთივის
 */

func swapTwoValues<T>(_ a: inout T, _ b: inout T) {

    let temporaryA = a
    a = b
    b = temporaryA
}
// <T> -> Declares that this is a generic function.
// T -> A generic placeholder for a data type.

// T-> აქ წარმოადგენს ფლეისჰოლდერს. იგი შეიძლება იყოს ყველა ტიპის (Str,Int... custom type).. T - თავისთავად არაფერს გულისხმობს იმის გარდა რომ იგი წარმოადგენს ფუნქციაში შემავალი მნიშვნელობების ერთ და იგივე ტიპს, ანუ a და b, ორივე უნდა იყოს ერთი (T) ტიპის.

 // In-Out PARAMETERS
/* თუ გჭირდება მცირე ინფორმაცია რას აკეთებს inout ფუნქცია:
 inout ნიშნავს რომ 
 */
/**ფუნქციის პარამეტრები ნაგულისხმევად მუდმივებია. ფუნქციის პარამეტრის მნიშვნელობის შეცვლის მცდელობა ამ ფუნქციის შიგნიდან კომპილაციის დროს შეცდომას იწვევს. ეს ნიშნავს, რომ პარამეტრის მნიშვნელობის შეცდომით შეცვლა შეუძლებელია. თუ გსურთ, რომ ფუნქციამ შეცვალოს პარამეტრის მნიშვნელობა და გსურთ, რომ ეს ცვლილებები ფუნქციის გამოძახების დასრულების შემდეგაც შენარჩუნდეს, განსაზღვრეთ ეს პარამეტრი, როგორც in-out პარამეტრი .
 
 in-out პარამეტრის ჩაწერისას, inout საკვანძო სიტყვა პარამეტრის ტიპის წინ უნდა განთავსდეს. in-out პარამეტრს აქვს მნიშვნელობა, რომელიც გადაეცემა ფუნქციას , შეცვლილია ფუნქციის მიერ და ფუნქციიდან უკან გადაეცემა თავდაპირველი მნიშვნელობის ჩასანაცვლებლად. in-out პარამეტრების ქცევისა და მასთან დაკავშირებული კომპილატორის ოპტიმიზაციის დეტალური განხილვისთვის იხილეთ In-Out პარამეტრები .

 ცვლადის გადაცემა მხოლოდ in-out პარამეტრის არგუმენტად შეგიძლიათ. არგუმენტად კონსტანტის ან ლიტერალის მნიშვნელობის გადაცემა შეუძლებელია, რადგან კონსტანტების და ლიტერალების შეცვლა შეუძლებელია. ცვლადის სახელის &in-out პარამეტრისთვის არგუმენტად გადაცემისას, ამპერსანდს --> & ათავსებთ უშუალოდ ცვლადის სახელის წინ, რათა მიუთითოთ, რომ მისი შეცვლა შესაძლებელია ფუნქციის მიერ.*/

